<HTML>
<HEAD>
<TITLE>class SMLVec2f</TITLE>
<link href="styles.css" rel="STYLESHEET" type="text/css">
</HEAD>

<BODY LINK="#0000ff" VLINK="#800080">
<P><a NAME="SMLVec2f"></a>[<A href="index.htm">SML Overview</a>]</P>
<h1>class SMLVec2f</h1>
<PRE>#include &quot;<A href="smlmath.h">smlmath.h</A>&quot;</PRE>
<P>Class <B>SMLVec2f</B> is a 2x1 vector of single precision floats. It includes data and methods, which allow forming 2-vectors, computing sum, difference, finding normalized vector, etc.</P>

<h2>Public Interface</h2>
<h3>Constructors</h3>
<table width=400 cellspacing=5>
<tr>
  <TD><P><A href="SMLVec2f.htm#constructor">constructors</A></P></TD>
</tr>
</table>

<h3>Access the data as an array</h3>
<table width=400 cellspacing=5>
<tr>
  <TD><P><A href="SMLVec2f.htm#data">data</A></P></TD>
</tr>
</table>

<h3>Rename to XY</h3>
<table width=400 cellspacing=5>
<tr>
  <TD><P><A href="SMLVec2f.htm#X">X</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#Y">Y</A></P></TD>
</tr>
</table>

<h3>Operators</h3>
<TABLE CELLSPACING=5 WIDTH=600>
<TR>
  <TD><P><A href="SMLVec2f.htm#operator_assign">operator=</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#operator_plus">operator+</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#operator_minus">operator-</A></P></TD>
</TR>
<TR>
  <TD><P><A href="SMLVec2f.htm#operator_times">operator*</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#operator_divide">operator/</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#operator_plusequal">operator+=</A></P></TD>  
</TR>
<TR>
  <TD><P><A href="SMLVec2f.htm#operator_minusequal">operator-=</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#operator_timesequal">operator*=</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#operator_divideequal">operator/=</A></P></TD>  
</TR>
</TABLE>

<h3>Methods</h3>  
<TABLE CELLSPACING=5 WIDTH=600>
<TR>
  <TD><P><A href="SMLVec2f.htm#Add">Add</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#Sub">Sub</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#Scale">Scale</A></P></TD>  
</TR>
<TR>
  <TD><P><A href="SMLVec2f.htm#Dot">Dot</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#Negate">Negate</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#Length">Length</A></P></TD>  
</TR>
<TR>
  <TD><P><A href="SMLVec2f.htm#LengthSquared">LengthSquared</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#Distance">Distance</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#DistanceSquared">DistanceSquared</A></P></TD>  
</TR>
<TR>
  <TD><P><A href="SMLVec2f.htm#Normalize">Normalize</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#operator_less">operator&lt;</A></P></TD>
  <TD><P><A href="SMLVec2f.htm#operator_equal">operator==</A></P></TD>  
</TR>
<TR>
  <TD><P><A href="SMLVec2f.htm#operator_notequal">operator!=</A></P></TD>
</TR>
</TABLE>

<HR>

<h2>Public Data</h2>
<P>float <B>x</B>;</P>
<P>float <B>y</B>;</P>
<P>Defines 2 components of the vector.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P><A NAME="constructor"></A>SMLLIBENTRY <B>SMLVec2f</B>(float <B><I>a</I></B>, float <B><I>b</I></B>);</P>
<h4>Discussion</h4>
<P>SMLVec2f object constructor. This constructor sets coordinates of vector equal to <B><I>a, b</I></B> correspondingly.</P>
<P><I>Example:</I></P>
<PRE><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(3.5f, 0.45f);</PRE>
<h4>Parameters</h4>
<P><B><I>a, b</I></B> - coordinates of new vector. These parameters should be of float type.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY <B>SMLVec2f</B>(float <B><I>v</I></B>[]);</P>
<h4>Discussion</h4>
<P>SMLVec2f object constructor. The constructor sets the coordinates of vector equal to first two elements of float-type array <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[2] = {1, 3}; <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd);</PRE>
<h4>Parameters</h4>
<P><B><I>v[]</I></B> - float-type array with coordinates of new vector. The array must have at least two elements.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<h4>Discussion</h4>
<P>SMLLIBENTRY <B>SMLVec2f</B>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v</I></B>);</P>
<P>SMLVec2f copy-constructor. The constructor sets coordinates of vector equal to those of vector <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd);<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> B(A);</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to an object of SMLVec2f type.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY <B>SMLVec2f</B>();</P>
<h4>Discussion</h4>
<P>Default SMLVec2f object constructor. The constructor sets all coordinates of vector equal to zero.</P>
<P><I>Example:</I></P>
<PRE><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A();</PRE>
<h4>Parameters</h4>
<P>No.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY const float* <A NAME="data"><B>data</B></A>() const;</P>
<P>SMLLIBENTRY float* <B>data</B>(); </P>
<h4>Discussion</h4>
<P>Methods are used for access to component data of the object, which are coordinates of a vector.</P>
<P><I>Example:</I></P>
<PRE>float *tmp, crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd);<BR>tmp = A.data(); // tmp[1] = 3</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods return float-type pointer to the first element of component data of the object.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="X"><B>X</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>x</I></B> of component data of the object. This variable is <B><I>x</I></B> - coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd);<BR>tmp = A.X(); // tmp = 1</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>x</I></B> of component data of the object.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>X</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>x</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>x</I></B> of component data of the object.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Y"><B>Y</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>y</I></B> of component data of the object. This variable is <B><I>y</I></B> - coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd);<BR>tmp = A.Y(); // tmp = 3</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>y</I></B> of component data of the object. This variable is <B><I>y</I></B> - coordinate of the current vector.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>Y</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>y</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>y</I></B> of component data of the object.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <A NAME="operator_assign"><B>operator=</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It sets coordinates of this vector to those of vector <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd), B;<BR>B = A;</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec2f type whose coordinates are assigned to the new vector.</P>
<h4>Return Value</h4>
<P>Returns reference to SMLVec2f-type object.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>friend SMLLIBENTRY bool <A NAME="operator_less"><B>operator&lt;</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v1</I></B>, const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v2</I></B>);</P>
<h4>Discussion</h4>
<P>Friend of the class. Function compares length of 2 vectors and returns <I>true</I>, if and only if vector <B><I>v1</I></B> is shorter than <B><I>v2</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd1[2] = {1, 2}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2);<BR>A = (A > B)?A:B // A = B</PRE>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>friend SMLLIBENTRY bool <A NAME="operator_equal"><B>operator==</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v1</I></B>, const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v2</I></B>);</P>
<h4>Discussion</h4>
<P>Friend of the class. Function returns <I>true</I>, if components of two vectors are equal to each other.</P>
<P><I>Example:</I></P>
<PRE>float crd1[2] = {1, 2}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2);<BR>A = (A == B)?A:B // A = B</PRE>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>friend SMLLIBENTRY bool <A NAME="operator_notequal"><B>operator!=</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v1</I></B>, const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v2</I></B>);</P>
<h4>Discussion</h4>
<P>Friend of the class. Function returns <I>true</I>, if components of 2 vectors are not equal.</P>
<P><I>Example:</I></P>
<PRE>float crd1[2] = {1, 2}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2);<BR>A = (A != B)?A:B // A = A</PRE>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY SMLVec2f <A NAME="operator_plus"><B>operator+</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes and returns sum of this vector and vector <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd1[2] = {1, 3}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2), C;<BR>C = A + B // C = {3, 5}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec2f type.</P>
<h4>Return Value</h4>
<P>Returns new object of SMLVec2f type, which is equal to sum of two vectors.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY SMLVec2f <A NAME="operator_minus"><B>operator-</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes and returns difference of this vector and vector <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd1[2] = {1, 3}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2), C;<BR>C = A - B // C = {-1, 1}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec2f type.</P>
<h4>Return Value</h4>
<P>Returns new object of SMLVec2f type, which is equal to difference of two vectors.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY SMLVec2f <A NAME="operator_times"><B>operator*</B></A>(float <B><I>var</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes and returns product of vector and variable <B><I>var</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd), C;<BR>C = A * 2.0f // C = {2, 6}</PRE>
<h4>Parameters</h4>
<P><B><I>var</I></B> - variable of float type.</P>
<h4>Return Value</h4>
<P>Returns new object of SMLVec2f type, which is equal to product of vector and variable.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY SMLVec2f <A NAME="operator_divide"><B>operator/</B></A>(float <B><I>var</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes and returns quotient of vector and variable <B><I>var</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd), C;<BR>C = A / 2.0f // C = {0.5, 1.5}</PRE>
<h4>Parameters</h4>
<P><B><I>var</I></B> - variable of float type.</P>
<h4>Return Value</h4>
<P>Returns new object of SMLVec2f type, which is quotient of vector and variable.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <A NAME="operator_plusequal"><B>operator+=</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes sum of two vectors. The result is assigned to this vector.</P>
<P><I>Example:</I></P>
<PRE>float crd1[2] = {1, 3}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2);<BR>A += B // A = {3, 5}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec2f type.</P>
<h4>Return Value</h4>
<P>Returns reference to current object of SMLVec2f type, which is sum of two vectors.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <A NAME="operator_minusequal"><B>operator-=</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes difference of two vectors. The result is assigned to this vector.</P>
<P><I>Example:</I></P>
<PRE>float crd1[2] = {1, 3}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2);<BR>A -= B // C = {-1, 1}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec2f type.</P>
<h4>Return Value</h4>
<P>Returns reference to current object of SMLVec2f type, which is difference of two vectors.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <A NAME="operator_timesequal"><B>operator*=</B></A>(float <B><I>var</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes product of vector and variable. The result is assigned to this vector.</P>
<P><I>Example:</I></P>
<PRE>float crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd);<BR>A *= 2.0f // C = {2, 6}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec2f type.</P>
<h4>Return Value</h4>
<P>Returns reference to the current object of SMLVec2f type, which is product of two vectors.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <A NAME="operator_divideequal"><B>operator/=</B></A>(float <B><I>var</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes quotient of vector and variable. The result is assigned to this vector.</P>
<P><I>Example:</I></P>
<PRE>float crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd);<BR>A /= 2.0f // C = {0.5, 1.5}</PRE>
<h4>Parameters</h4>
<P><B><I>var</I></B> - reference to object of SMLVec2f type.</P>
<h4>Return Value</h4>
<P>Returns reference to the current object of SMLVec2f type, which is quotient of the vector and variable.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY void <A NAME="Add"><B>Add</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>vec1</I></B>, const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>vec2</I></B>);</P>
<h4>Discussion</h4>
<P>Method sets coordinates of this vector equal to sum of corresponding coordinates of two vectors <B><I>vec1</I></B> and  <B><I>vec2</I></B></P>
<P><I>Example:</I></P>
<PRE>float crd1[2] = {1, 3}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2), C;<BR>C.Add(A, B); // C = {3, 5}</PRE>
<h4>Parameters</h4>
<P><B><I>vec1, vec2</I></B> - vectors to be added .</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY void <A NAME="Sub"><B>Sub</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>vec1</I></B>, const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>vec2</I></B>);</P>
<h4>Discussion</h4>
<P>Method sets coordinates of this vector equal to difference of corresponding coordinates of two vectors <B><I>vec1</I></B> and <B><I>vec2</I></B></P>
<P><I>Example:</I></P>
<PRE>float crd1[2] = {1, 3}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2), C;<BR>C.Sub(A,B); // C = {-1, 1}</PRE>
<h4>Parameters</h4>
<P><B><I>vec1, vec2</I></B> - vectors, difference of which is to be computed.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY void <A NAME="Scale"><B>Scale</B></A>(float <B><I>var</I></B>, const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Method sets coordinates of vector equal to product of variable <B><I>var </I></B>and vector <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[2] = {1, 3};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1);<BR>A.Scale(2.0f); // A = {2, 6}</PRE>
<h4>Parameters</h4>
<P><B><I>var</I></B> - variable of float type (scale parameter).</P>
<P><B><I>v</I></B> - reference to vector to be scaled.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Dot"><B>Dot</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>vec</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method computes scalar product of this vector and vector <B><I>vec</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float sp, crd1[2] = {1, 3}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1), B(crd2);<BR>sp = A.Dot(B); // sp = 8</PRE>
<h4>Parameters</h4>
<P><B><I>vec</I></B> - reference to the second vector of the 
scalar product.</P>
<h4>Return Value</h4>
<P>Returns scalar product of this vector and vector <B><I>vec</I></B>.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float <B>Dot</B>(const float * const <B><I>vec</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method computes scalar product of this vector and vector defined by float array <B><I>vec</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float sp, crd1[2] = {1, 3}, crd2[2] = {2, 2};<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(crd1);<BR>sp = A.Dot(crd2); // sp = 8</PRE>
<h4>Parameters</h4>
<P><B><I>vec</I></B> - constant pointer to the second constant vector of the scalar product.</P>
<h4>Return Value</h4>
<P>Returns scalar product of this vector and vector <B><I>vec</I></B>.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <A NAME="Negate"><B>Negate</B></A>();</P>
<h4>Discussion</h4>
<P>Method replaces this vector with vector (-x, -y).</P>
<P><I>Example:</I></P>
<PRE><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(1,3); A.Negate(); // A = {-1, -3}</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to the current object.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Length"><B>Length</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method computes length of this vector.</P>
<P><I>Example:</I></P>
<PRE>float l;<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(3,4); l = A.Length(); // l = 5</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns length of this vector.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="LengthSquared"><B>LengthSquared</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method computes length squared of this vector.</P>
<P><I>Example:</I></P>
<PRE>float ls;<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(3,4); ls = A.LengthSquared(); // ls = 25</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns length squared of this vector.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Distance"><B>Distance</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>vec</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method computes distance between this vector (considered as a point) and vector <B><I>vec</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float d;<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(3,4), B(4,3);<BR>d = A.Distance(B); // d = 1</PRE>
<h4>Parameters</h4>
<P><B><I>vec</I></B> - radius-vector of the second point. Reference to object of SMLVec2f type.</P>
<h4>Return Value</h4>
<P>Methods returns distance between two points.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="DistanceSquared"><B>DistanceSquared</B></A>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>vec</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method computes distance squared between this point and vector <B><I>vec</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float ds;<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(2,4), B(4,3);<BR>ds = A.Distance(B); // ds = 5</PRE>
<h4>Parameters</h4>
<P><B><I>vec</I></B> - radius-vector of the second point. Reference to object of SMLVec2f type.</P>
<h4>Return Value</h4>
<P>Methods returns distance squared between two points.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float<B>operator*</B>(const <A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A>&amp; <B><I>vec</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes scalar product of the component this vector and vector <B><I>vec</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float sp;<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(1,2), B(2,2);<BR>sp = A * B; // sp = 5</PRE>
<h4>Parameters</h4>
<P><B><I>vec</I></B> - reference to object of SMLVec2f type.</P>
<h4>Return Value</h4>
<P>Returns scalar product of the vectors.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Normalize"><B>Normalize</B></A>();</P>
<h4>Discussion</h4>
<P>Method normalizes this vector. If length of the vector is smaller than 1 / FLT_EPSILON, the normalized vector is created in accordance with general rules, i. e. normalized vector is equal to this vector divided on its length. If norm of the vector is greater than 1 / FLT_EPSILON, the method forms unit vector with coordinates {0; 1}.</P>
<P><I>Example:</I></P>
<PRE>float n;<BR><A href="SMLVec2f.htm#SMLVec2f">SMLVec2f</A> A(3,4);<BR>n = A.Normalize(); // n = 5, A = {0.6, 0.8}</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value equal to the inverted length of this vector.</P>
<p>[<A href="SMLVec2f.htm#SMLVec2f">top</A>]</p><HR>

</BODY>
</HTML>
